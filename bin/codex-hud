#!/usr/bin/env bash
#
# codex-hud - Wrapper script for Codex CLI with HUD display
# Launches Codex in a tmux session with a status bar pane
#
# Environment variables:
#   CODEX_HUD_POSITION - HUD pane position: bottom (default), top
#   CODEX_HUD_HEIGHT   - HUD pane height in lines (default: 3)
#   CODEX_HUD_NO_ATTACH - If set, don't attach to existing session
#

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HUD_DIR="$(dirname "$SCRIPT_DIR")"
HUD_HEIGHT="${CODEX_HUD_HEIGHT:-3}"
HUD_POSITION="${CODEX_HUD_POSITION:-bottom}"
SESSION_MODE="${CODEX_HUD_SESSION_MODE:-unique}"
TMUX_MOUSE="${CODEX_HUD_TMUX_MOUSE:-on}"

# Escape a single shell argument safely.
shell_escape() {
    local value="$1"
    value=$(printf '%s' "$value" | sed "s/'/'\"'\"'/g")
    printf "'%s'" "$value"
}

# Hash the working directory for shared session names (macOS-friendly).
hash_cwd() {
    local input="$1"
    local hash=""

    if command -v md5sum >/dev/null 2>&1; then
        hash=$(printf '%s' "$input" | md5sum | awk '{print $1}')
    elif command -v md5 >/dev/null 2>&1; then
        hash=$(printf '%s' "$input" | md5)
        hash="${hash##* }"
    elif command -v shasum >/dev/null 2>&1; then
        hash=$(printf '%s' "$input" | shasum -a 256 | awk '{print $1}')
    fi

    if [[ -n "$hash" ]]; then
        echo "${hash:0:8}"
    else
        echo "$$"
    fi
}

# Check for bypass mode - run original codex directly without HUD
if [[ -n "${CODEX_HUD_BYPASS:-}" ]]; then
    exec command codex "$@"
fi

# Find the real codex executable (not our alias)
find_real_codex() {
    local codex_path=""
    
    # Method 1: Check common installation paths FIRST (most reliable)
    # This avoids issues with aliases/functions
    local common_paths=(
        "/opt/homebrew/bin/codex"
        "/usr/local/bin/codex"
        "/usr/bin/codex"
        "$HOME/.local/bin/codex"
        "$HOME/bin/codex"
        "$HOME/.npm-global/bin/codex"
    )
    for path in "${common_paths[@]}"; do
        if [[ -x "$path" ]]; then
            # Verify it's not a symlink to our wrapper
            local real_path
            real_path=$(readlink -f "$path" 2>/dev/null || realpath "$path" 2>/dev/null || echo "$path")
            if [[ "$real_path" != *"codex-hud"* ]]; then
                codex_path="$path"
                break
            fi
        fi
    done
    
    # Method 2: Use 'whence -p' for zsh or 'type -P' for bash (gets path ignoring aliases/functions)
    if [[ -z "$codex_path" ]]; then
        local type_path=""
        # Try zsh's whence -p first (works in zsh)
        if whence -p codex &>/dev/null 2>&1; then
            type_path=$(whence -p codex 2>/dev/null)
        # Fall back to bash's type -P
        elif type -P codex &>/dev/null 2>&1; then
            type_path=$(type -P codex 2>/dev/null)
        fi
        if [[ -n "$type_path" ]] && [[ "$type_path" != *"codex-hud"* ]]; then
            codex_path="$type_path"
        fi
    fi
    
    # Method 3: Search PATH manually, skipping our wrapper
    if [[ -z "$codex_path" ]]; then
        local IFS=':'
        for dir in $PATH; do
            local candidate="$dir/codex"
            if [[ -x "$candidate" ]] && [[ "$candidate" != *"codex-hud"* ]]; then
                local real_path
                real_path=$(readlink -f "$candidate" 2>/dev/null || realpath "$candidate" 2>/dev/null || echo "$candidate")
                if [[ "$real_path" != *"codex-hud"* ]]; then
                    codex_path="$candidate"
                    break
                fi
            fi
        done
    fi
    
    echo "$codex_path"
}

# Cache the real codex path
REAL_CODEX_PATH=$(find_real_codex)

# Generate session name. "shared" reuses per-directory sessions, "unique" always creates new.
SESSION_BASE="codex-hud-$(hash_cwd "$PWD")"
if [[ "$SESSION_MODE" == "shared" ]]; then
    SESSION_NAME="$SESSION_BASE"
else
    SESSION_NAME="${SESSION_BASE}-$(date +%s)-$$"
fi
# Record HUD start time for session scoping (seconds since epoch).
SESSION_START_TS="$(date +%s)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print error message and exit
error() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

# Print warning message
warn() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

# Print info message
info() {
    echo -e "${GREEN}Info:${NC} $1"
}

# Print step message
step() {
    echo -e "${BLUE}==>${NC} $1"
}

# Check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Detect OS and package manager
detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ -f /etc/debian_version ]]; then
        echo "debian"
    elif [[ -f /etc/redhat-release ]]; then
        echo "redhat"
    elif [[ -f /etc/arch-release ]]; then
        echo "arch"
    elif [[ -f /etc/alpine-release ]]; then
        echo "alpine"
    else
        echo "unknown"
    fi
}

# Install tmux automatically
install_tmux() {
    local os
    os=$(detect_os)
    
    step "Installing tmux..."
    
    case "$os" in
        macos)
            if command_exists brew; then
                brew install tmux
            else
                error "Homebrew not found. Please install Homebrew first: https://brew.sh"
            fi
            ;;
        debian)
            if command_exists sudo; then
                sudo apt-get update && sudo apt-get install -y tmux
            else
                apt-get update && apt-get install -y tmux
            fi
            ;;
        redhat)
            if command_exists sudo; then
                sudo yum install -y tmux || sudo dnf install -y tmux
            else
                yum install -y tmux || dnf install -y tmux
            fi
            ;;
        arch)
            if command_exists sudo; then
                sudo pacman -S --noconfirm tmux
            else
                pacman -S --noconfirm tmux
            fi
            ;;
        alpine)
            if command_exists sudo; then
                sudo apk add tmux
            else
                apk add tmux
            fi
            ;;
        *)
            error "Could not detect OS for automatic tmux installation.

Please install tmux manually:
  Linux (Debian/Ubuntu): sudo apt install tmux
  Linux (RHEL/CentOS):   sudo yum install tmux
  Linux (Arch):          sudo pacman -S tmux
  macOS:                 brew install tmux"
            ;;
    esac
    
    # Verify installation
    if command_exists tmux; then
        info "tmux installed successfully!"
    else
        error "tmux installation failed. Please install manually."
    fi
}

# Check dependencies (with auto-install for tmux)
check_dependencies() {
    # Check tmux - auto-install if missing
    if ! command_exists tmux; then
        warn "tmux is not installed."
        echo ""
        read -p "Would you like to install tmux automatically? [Y/n] " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
            install_tmux
        else
            error "tmux is required for codex-hud. Please install it manually."
        fi
    fi
    
    if ! command_exists codex; then
        error "codex CLI is not found in PATH.

Install Codex CLI from: https://github.com/openai/codex"
    fi
    
    if ! command_exists node; then
        error "Node.js is required but not installed.

Install Node.js 18+ from: https://nodejs.org/"
    fi
}

# Enable tmux mouse mode to allow trackpad scrolling in copy mode.
configure_tmux_mouse() {
    local session_name="$1"
    if [[ "$TMUX_MOUSE" == "on" ]]; then
        tmux set-option -t "$session_name" mouse on
    fi
}

# Build the HUD renderer if needed
build_hud() {
    local dist_file="$HUD_DIR/dist/index.js"
    local src_file="$HUD_DIR/src/index.ts"
    
    # Check if node_modules exists
    if [[ ! -d "$HUD_DIR/node_modules" ]]; then
        step "Installing dependencies..."
        (cd "$HUD_DIR" && npm install) || error "Failed to install dependencies"
    fi
    
    # Check if we need to build
    if [[ ! -f "$dist_file" ]] || [[ "$src_file" -nt "$dist_file" ]]; then
        step "Building HUD renderer..."
        (cd "$HUD_DIR" && npm run build) || error "Failed to build HUD renderer"
    fi
}

# Get the current working directory for Codex
get_cwd() {
    pwd
}

# Check if session already exists and is usable
check_existing_session() {
    if [[ -n "${CODEX_HUD_NO_ATTACH:-}" ]]; then
        return 1
    fi
    
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        return 0
    fi
    return 1
}

# Cleanup function - only cleanup on error, not on normal detach
cleanup() {
    # Only kill session if we created it AND there was an error
    # Normal detach (Ctrl+B D) should leave session running
    local exit_code=$?
    if [[ "${SESSION_CREATED:-}" == "true" ]] && [[ $exit_code -ne 0 ]]; then
        if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
            tmux kill-session -t "$SESSION_NAME" 2>/dev/null || true
        fi
    fi
}

# Create new tmux session with HUD
create_session() {
    local cwd="$1"
    shift
    local codex_args=("$@")
    
    # Calculate terminal dimensions
    local term_height
    local term_width
    term_height=$(tput lines 2>/dev/null || echo 24)
    term_width=$(tput cols 2>/dev/null || echo 80)
    
    local escaped_cwd
    escaped_cwd=$(shell_escape "$cwd")

    # Build the codex command string
    # Use the real codex path or 'command codex' to bypass any shell aliases
    # This prevents infinite recursion if user has aliased codex to codex-hud
    local codex_cmd
    if [[ -n "$REAL_CODEX_PATH" ]]; then
        codex_cmd=$(shell_escape "$REAL_CODEX_PATH")
    else
        codex_cmd="command codex"
    fi
    if [[ ${#codex_args[@]} -gt 0 ]]; then
        # Properly quote arguments
        for arg in "${codex_args[@]}"; do
            codex_cmd="$codex_cmd $(shell_escape "$arg")"
        done
    fi
    
    # Wrap codex command to kill tmux session when codex exits
    # This ensures the session is cleaned up when user exits codex (Ctrl+C or normal exit)
    local escaped_session
    escaped_session=$(shell_escape "$SESSION_NAME")
    local wrapped_codex_cmd="cd $escaped_cwd && $codex_cmd; tmux kill-session -t $escaped_session 2>/dev/null || true"
    
    # HUD command
    local hud_path
    hud_path=$(shell_escape "$HUD_DIR/dist/index.js")
    local hud_cmd="cd $escaped_cwd && CODEX_HUD_CWD=$escaped_cwd CODEX_HUD_SESSION_START=$(shell_escape "$SESSION_START_TS") node $hud_path"
    
    # Create new detached session with the HUD pane first
    # This ensures codex gets the main interactive pane
    if [[ "$HUD_POSITION" == "top" ]]; then
        # Create session with HUD at top
        tmux new-session -d -s "$SESSION_NAME" -x "$term_width" -y "$term_height" "$hud_cmd"
        configure_tmux_mouse "$SESSION_NAME"
        # Split below for codex (main pane)
        tmux split-window -v -t "$SESSION_NAME" -l $((term_height - HUD_HEIGHT - 1))
        # Send codex command to the new pane (pane 1)
        tmux send-keys -t "$SESSION_NAME:.1" "$wrapped_codex_cmd" C-m
        # Select the codex pane
        tmux select-pane -t "$SESSION_NAME:.1"
    else
        # Default: HUD at bottom
        # Create session, start with shell
        tmux new-session -d -s "$SESSION_NAME" -x "$term_width" -y "$term_height"
        configure_tmux_mouse "$SESSION_NAME"
        # Send codex command to main pane (pane 0)
        tmux send-keys -t "$SESSION_NAME:.0" "$wrapped_codex_cmd" C-m
        # Split below for HUD
        tmux split-window -v -t "$SESSION_NAME" -l "$HUD_HEIGHT" "$hud_cmd"
        # Select the codex pane (pane 0)
        tmux select-pane -t "$SESSION_NAME:.0"
    fi
    
    SESSION_CREATED="true"
}

# Create a new window in the current tmux session (when already inside tmux)
create_window_in_current_session() {
    local cwd="$1"
    shift
    local codex_args=("$@")
    
    local escaped_cwd
    escaped_cwd=$(shell_escape "$cwd")

    # Build the codex command string
    # Use the real codex path or 'command codex' to bypass any shell aliases
    # This prevents infinite recursion if user has aliased codex to codex-hud
    local codex_cmd
    if [[ -n "$REAL_CODEX_PATH" ]]; then
        codex_cmd=$(shell_escape "$REAL_CODEX_PATH")
    else
        codex_cmd="command codex"
    fi
    if [[ ${#codex_args[@]} -gt 0 ]]; then
        for arg in "${codex_args[@]}"; do
            codex_cmd="$codex_cmd $(shell_escape "$arg")"
        done
    fi
    
    # HUD command
    local hud_path
    hud_path=$(shell_escape "$HUD_DIR/dist/index.js")
    local hud_cmd="cd $escaped_cwd && CODEX_HUD_CWD=$escaped_cwd CODEX_HUD_SESSION_START=$(shell_escape "$SESSION_START_TS") node $hud_path"
    
    # Create a new window in the current session
    local window_name="codex-hud"
    tmux new-window -n "$window_name"
    
    # Get the window index for cleanup command
    local window_index
    window_index=$(tmux display-message -p '#{window_index}')
    
    # Wrap codex command to close the window when codex exits
    local wrapped_codex_cmd="cd $escaped_cwd && $codex_cmd; tmux kill-window -t :$window_index 2>/dev/null || true"
    
    # Send codex command to the new window
    tmux send-keys "$wrapped_codex_cmd" C-m
    
    # Split for HUD based on position
    if [[ "$HUD_POSITION" == "top" ]]; then
        tmux split-window -v -b -l "$HUD_HEIGHT" "$hud_cmd"
        # Select the codex pane (pane 1, below HUD)
        tmux select-pane -t :.1
    else
        # Default: HUD at bottom
        tmux split-window -v -l "$HUD_HEIGHT" "$hud_cmd"
        # Select the codex pane (pane 0, above HUD)
        tmux select-pane -t :.0
    fi
    
    info "Created new window '$window_name' with Codex and HUD"
}

# Main function
main() {
    # Parse arguments
    local codex_args=("$@")
    
    # Check dependencies
    check_dependencies
    
    # Build HUD if needed
    build_hud
    
    # Get current working directory
    local cwd
    cwd=$(get_cwd)
    
    # Check if already inside tmux
    if [[ -n "${TMUX:-}" ]]; then
        # We're inside tmux - create a new window instead of a new session
        info "Running inside tmux - creating new window..."
        create_window_in_current_session "$cwd" "${codex_args[@]}"
        return 0
    fi
    
    # Check for existing session (only when not inside tmux)
    if check_existing_session; then
        info "Attaching to existing session: $SESSION_NAME"
        tmux select-pane -t "$SESSION_NAME:.0" 2>/dev/null || true
        tmux attach-session -t "$SESSION_NAME"
        return 0
    fi
    
    # Set up cleanup trap only for errors (ERR signal)
    trap cleanup ERR
    
    # Create new session
    info "Starting Codex with HUD (session: $SESSION_NAME)..."
    create_session "$cwd" "${codex_args[@]}"
    
    # Attach to the session
    tmux select-pane -t "$SESSION_NAME:.0" 2>/dev/null || true
    tmux attach-session -t "$SESSION_NAME"
}

# Show help
show_help() {
    cat << EOF
codex-hud - Codex CLI with HUD display

Usage: codex-hud [options] [codex options...]

This wrapper launches Codex in a tmux session with a real-time status bar
showing model info, git status, project info, token usage, and more.

All arguments are passed through to the codex command.

Options:
  -h, --help          Show this help message
  --kill              Kill existing session for current directory
  --kill-all          Kill all codex-hud sessions
  --list              List all codex-hud sessions

Environment Variables:
  CODEX_HUD_POSITION     HUD pane position: bottom (default), top
  CODEX_HUD_HEIGHT       HUD pane height in lines (default: 3)
  CODEX_HUD_NO_ATTACH    If set, always create new session
  CODEX_HUD_SESSION_MODE Session mode: unique (default), shared
  CODEX_HUD_TMUX_MOUSE   Enable tmux mouse mode for scrolling: on (default), off
  CODEX_HUD_BYPASS       If set, bypass HUD and run codex directly

Requirements:
  - tmux (auto-installed if missing)
  - Node.js 18+
  - Codex CLI

Behavior:
  - If run outside tmux: creates a new tmux session
  - If run inside tmux: creates a new window in current session

Examples:
  codex-hud                    Start Codex with HUD
  codex-hud --model gpt-5      Start with specific model
  codex-hud "help me debug"    Start with initial prompt
  codex-hud --kill             Kill existing session
  codex-hud --kill-all         Kill all sessions
  CODEX_HUD_POSITION=top codex-hud  HUD on top

For more information, see: https://github.com/openai/codex
EOF
}

# Kill existing session
kill_session() {
    if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
        tmux kill-session -t "$SESSION_NAME"
        info "Session '$SESSION_NAME' killed."
    else
        warn "No session found: $SESSION_NAME"
    fi
}

# Kill all codex-hud sessions
kill_all_sessions() {
    local sessions
    sessions=$(tmux list-sessions 2>/dev/null | grep "^codex-hud-" | cut -d: -f1 || true)
    
    if [[ -z "$sessions" ]]; then
        info "No codex-hud sessions found."
        return 0
    fi
    
    echo "Found sessions:"
    echo "$sessions" | sed 's/^/  /'
    echo ""
    
    while IFS= read -r session; do
        if [[ -n "$session" ]]; then
            tmux kill-session -t "$session" 2>/dev/null || true
            info "Killed session: $session"
        fi
    done <<< "$sessions"
}

# List all codex-hud sessions
list_sessions() {
    echo "Active codex-hud sessions:"
    tmux list-sessions 2>/dev/null | grep "^codex-hud-" || echo "  (none)"
}

# Check for special flags first
case "${1:-}" in
    -h|--help)
        show_help
        exit 0
        ;;
    --kill)
        # Need to check dependencies to ensure tmux is available
        if command_exists tmux; then
            kill_session
        else
            error "tmux not installed"
        fi
        exit 0
        ;;
    --kill-all)
        if command_exists tmux; then
            kill_all_sessions
        else
            error "tmux not installed"
        fi
        exit 0
        ;;
    --list)
        if command_exists tmux; then
            list_sessions
        else
            error "tmux not installed"
        fi
        exit 0
        ;;
esac

# Allow sourcing for tests without running main.
if [[ -n "${CODEX_HUD_LIB_ONLY:-}" ]]; then
    if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
        return 0
    fi
    exit 0
fi

# Run main
main "$@"
